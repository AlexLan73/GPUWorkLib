# DrvGPU Command Queue System

## ĞĞ³Ğ»Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ

1. [ĞĞ±Ğ·Ğ¾Ñ€ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´](#Ğ¾Ğ±Ğ·Ğ¾Ñ€-ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹-ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´)
2. [CommandQueuePool](#commandqueuepool)
3. [Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ Ğ±ÑĞºĞµĞ½Ğ´Ğ¾Ğ¼](#Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ-Ñ-Ğ±ÑĞºĞµĞ½Ğ´Ğ¾Ğ¼)
4. [ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ](#Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ñ‹-Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ)
5. [Thread Safety](#thread-safety)
6. [ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸](#Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ-Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸)

---

## ĞĞ±Ğ·Ğ¾Ñ€ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´

Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´ DrvGPU Ğ¾Ğ±ĞµÑĞ¿ĞµÑ‡Ğ¸Ğ²Ğ°ĞµÑ‚ ÑÑ„Ñ„ĞµĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾Ğµ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‡ĞµÑ€ĞµĞ´ÑĞ¼Ğ¸ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´ GPU Ñ‡ĞµÑ€ĞµĞ· Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½ Object Pool.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Command Queue Architecture                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                   OpenCLBackend                             â”‚   â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚   â”‚  â”‚            CommandQueuePool (main queue)            â”‚   â”‚   â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚   â”‚                          â”‚                                     â”‚
â”‚   â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚   â”‚       â–¼                  â–¼                  â–¼                â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚   â”‚  â”‚   Queue 0   â”‚   â”‚   Queue 1   â”‚   â”‚   Queue N   â”‚        â”‚
â”‚   â”‚  â”‚  (active)   â”‚   â”‚   (idle)    â”‚   â”‚   (idle)    â”‚        â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ ĞºĞ»Ğ°ÑÑÑ‹

| ĞšĞ»Ğ°ÑÑ | Ğ¤Ğ°Ğ¹Ğ» | ĞĞ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ |
|-------|------|------------|
| `CommandQueuePool` | command_queue_pool.hpp/cpp | ĞŸÑƒĞ» Ğ¾Ñ‡ĞµÑ€ĞµĞ´ĞµĞ¹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´ |
| `OpenCLBackend` | opencl_backend.hpp/cpp | Ğ‘ÑĞºĞµĞ½Ğ´ Ñ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¼ Ğ¿ÑƒĞ»Ğ¾Ğ¼ |

---

## CommandQueuePool

### ĞĞ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ

`CommandQueuePool` Ñ€ĞµĞ°Ğ»Ğ¸Ğ·ÑƒĞµÑ‚ Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½ Object Pool Ğ´Ğ»Ñ Ğ¿ĞµÑ€ĞµĞ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¾Ñ‡ĞµÑ€ĞµĞ´ĞµĞ¹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´ OpenCL, Ñ‡Ñ‚Ğ¾ Ğ·Ğ½Ğ°Ñ‡Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ ÑĞ½Ğ¸Ğ¶Ğ°ĞµÑ‚ Ğ½Ğ°ĞºĞ»Ğ°Ğ´Ğ½Ñ‹Ğµ Ñ€Ğ°ÑÑ…Ğ¾Ğ´Ñ‹ Ğ½Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ/ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‡ĞµÑ€ĞµĞ´ĞµĞ¹.

### Ğ¤Ğ°Ğ¹Ğ»

[`opencl/command_queue_pool.hpp`](../../include/DrvGPU/backends/opencl/command_queue_pool.hpp)

### Ğ˜Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ ĞºĞ»Ğ°ÑÑĞ°

```cpp
class CommandQueuePool {
public:
    /**
     * @brief Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¿ÑƒĞ» Ğ¾Ñ‡ĞµÑ€ĞµĞ´ĞµĞ¹
     * @param context OpenCL ĞºĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚
     * @param device Ğ£ÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ²Ğ¾
     * @param initial_size ĞĞ°Ñ‡Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ¿ÑƒĞ»Ğ°
     */
    explicit CommandQueuePool(cl_context context, 
                               cl_device_id device,
                               size_t initial_size = 4);
    
    ~CommandQueuePool();
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Pool Management
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    /**
     * @brief ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¾Ñ‡ĞµÑ€ĞµĞ´ÑŒ Ğ¸Ğ· Ğ¿ÑƒĞ»Ğ°
     * @return cl_command_queue
     * 
     * Ğ•ÑĞ»Ğ¸ Ğ¿ÑƒĞ» Ğ¿ÑƒÑÑ‚, ÑĞ¾Ğ·Ğ´Ğ°Ñ‘Ñ‚ Ğ½Ğ¾Ğ²ÑƒÑ Ğ¾Ñ‡ĞµÑ€ĞµĞ´ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸.
     * Ğ’Ğ½Ğ¸Ğ¼Ğ°Ğ½Ğ¸Ğµ: Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ½Ğ°Ñ Ğ¾Ñ‡ĞµÑ€ĞµĞ´ÑŒ ÑÑ‡Ğ¸Ñ‚Ğ°ĞµÑ‚ÑÑ "Ğ² Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¸"
     * Ğ¸ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰ĞµĞ½Ğ° Ñ‡ĞµÑ€ĞµĞ· ReleaseQueue().
     */
    cl_command_queue AcquireQueue();
    
    /**
     * @brief Ğ’ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ğ¾Ñ‡ĞµÑ€ĞµĞ´ÑŒ Ğ² Ğ¿ÑƒĞ»
     * @param queue ĞÑ‡ĞµÑ€ĞµĞ´ÑŒ Ğ´Ğ»Ñ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚Ğ°
     * 
     * ĞÑ‡ĞµÑ€ĞµĞ´ÑŒ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ° ÑÑ‚Ğ¸Ğ¼ Ğ¿ÑƒĞ»Ğ¾Ğ¼ Ğ¸Ğ»Ğ¸ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ° Ñ Ğ½Ğ¸Ğ¼.
     */
    void ReleaseQueue(cl_command_queue queue);
    
    /**
     * @brief Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ¿ÑƒĞ»Ğ°
     * @param max_size ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¾Ñ‡ĞµÑ€ĞµĞ´ĞµĞ¹
     * 
     * ĞŸÑ€Ğ¸ Ğ¿Ñ€ĞµĞ²Ñ‹ÑˆĞµĞ½Ğ¸Ğ¸ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ° Ğ½Ğ¾Ğ²Ñ‹Ğµ Ğ¾Ñ‡ĞµÑ€ĞµĞ´Ğ¸ Ğ½Ğµ ÑĞ¾Ğ·Ğ´Ğ°ÑÑ‚ÑÑ.
     */
    void SetMaxSize(size_t max_size);
    
    /**
     * @brief ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğ¹ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ¿ÑƒĞ»Ğ°
     * @return ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¾Ñ‡ĞµÑ€ĞµĞ´ĞµĞ¹ Ğ² Ğ¿ÑƒĞ»Ğµ
     */
    size_t GetPoolSize() const;
    
    /**
     * @brief ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ¾Ñ‡ĞµÑ€ĞµĞ´ĞµĞ¹
     * @return ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ ÑĞ²Ğ¾Ğ±Ğ¾Ğ´Ğ½Ñ‹Ñ… Ğ¾Ñ‡ĞµÑ€ĞµĞ´ĞµĞ¹
     */
    size_t GetAvailableCount() const;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Operations
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    /**
     * @brief Ğ¡Ğ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²ÑĞµ Ğ¾Ñ‡ĞµÑ€ĞµĞ´Ğ¸ Ğ² Ğ¿ÑƒĞ»Ğµ
     * 
     * Ğ’Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ clFinish Ğ´Ğ»Ñ Ğ²ÑĞµÑ… Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ¾Ñ‡ĞµÑ€ĞµĞ´ĞµĞ¹.
     * Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ÑÑ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğ¹ ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ğ¿ĞµÑ€ĞµĞ´ Ğ¾Ñ‡Ğ¸ÑÑ‚ĞºĞ¾Ğ¹.
     */
    void SynchronizeAll();
    
    /**
     * @brief ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ Ğ¿ÑƒĞ» (Ğ¾ÑĞ²Ğ¾Ğ±Ğ¾Ğ´Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ Ğ¾Ñ‡ĞµÑ€ĞµĞ´Ğ¸)
     * 
     * ĞÑĞ²Ğ¾Ğ±Ğ¾Ğ¶Ğ´Ğ°ĞµÑ‚ Ğ²ÑĞµ Ğ¾Ñ‡ĞµÑ€ĞµĞ´Ğ¸ Ğ¸ Ğ¾Ñ‡Ğ¸Ñ‰Ğ°ĞµÑ‚ Ğ²Ğ½ÑƒÑ‚Ñ€ĞµĞ½Ğ½Ğ¸Ğµ ÑĞ¿Ğ¸ÑĞºĞ¸.
     */
    void Clear();
    
    /**
     * @brief ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ, Ğ¿ÑƒÑÑ‚ Ğ»Ğ¸ Ğ¿ÑƒĞ»
     */
    bool IsEmpty() const;
    
    /**
     * @brief ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ, Ğ¿Ğ¾Ğ»Ğ¾Ğ½ Ğ»Ğ¸ Ğ¿ÑƒĞ»
     */
    bool IsFull() const;

private:
    cl_context context_;
    cl_device_id device_;
    size_t max_size_;
    
    std::vector<cl_command_queue> available_;
    std::vector<cl_command_queue> in_use_;
    
    mutable std::mutex mutex_;
};
```

### Ğ’Ğ½ÑƒÑ‚Ñ€ĞµĞ½Ğ½ÑÑ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°

```
CommandQueuePool Internal State
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Pool Manager                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  context_: cl_context                   â”‚
â”‚  device_: cl_device_id                  â”‚
â”‚  max_size_: size_t (default: SIZE_MAX)  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  available_: vector<cl_command_queue>   â”‚
â”‚     [Queue 0] - idle, ready to use      â”‚
â”‚     [Queue 1] - idle, ready to use      â”‚
â”‚     ...                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  in_use_: vector<cl_command_queue>      â”‚
â”‚     [Queue A] - acquired, in use        â”‚
â”‚     [Queue B] - acquired, in use        â”‚
â”‚     ...                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  mutex_: std::mutex (thread safety)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Ğ–Ğ¸Ğ·Ğ½ĞµĞ½Ğ½Ñ‹Ğ¹ Ñ†Ğ¸ĞºĞ» Ğ¾Ñ‡ĞµÑ€ĞµĞ´Ğ¸

```
AcquireQueue()                    ReleaseQueue()
     â”‚                                â”‚
     â–¼                                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ availableâ”‚ â”€â”€â–º â”‚  in_use â”‚ â”€â”€â–º â”‚availableâ”‚
â”‚   [0]    â”‚     â”‚   [A]   â”‚     â”‚   [0]   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ Ğ±ÑĞºĞµĞ½Ğ´Ğ¾Ğ¼

### OpenCLBackend Ñ CommandQueuePool

```cpp
class OpenCLBackend : public IBackend {
public:
    OpenCLBackend();
    ~OpenCLBackend() override;
    
    // ... Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹ ...
    
    /**
     * @brief ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¿ÑƒĞ» Ğ¾Ñ‡ĞµÑ€ĞµĞ´ĞµĞ¹
     */
    CommandQueuePool& GetCommandQueuePool() {
        return command_queue_pool_;
    }
    
    /**
     * @brief ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¾Ñ‡ĞµÑ€ĞµĞ´ÑŒ Ğ´Ğ»Ñ Ğ°ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ğ¾Ğ¹ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸
     */
    cl_command_queue AcquireCommandQueue() {
        return command_queue_pool_.AcquireQueue();
    }
    
    /**
     * @brief Ğ’ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ğ¾Ñ‡ĞµÑ€ĞµĞ´ÑŒ
     */
    void ReleaseCommandQueue(cl_command_queue queue) {
        command_queue_pool_.ReleaseQueue(queue);
    }
    
private:
    // ... Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ Ñ‡Ğ»ĞµĞ½Ñ‹ ...
    CommandQueuePool command_queue_pool_;
};
```

---

## ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ

### ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ 1: Ğ‘Ğ°Ğ·Ğ¾Ğ²Ğ¾Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ°

```cpp
#include "backends/opencl/command_queue_pool.hpp"

void processWithPool(cl_context context, cl_device_id device) {
    // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¿ÑƒĞ» Ñ 4 Ğ¾Ñ‡ĞµÑ€ĞµĞ´ÑĞ¼Ğ¸
    drv_gpu_lib::CommandQueuePool pool(context, device, 4);
    
    // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¾Ñ‡ĞµÑ€ĞµĞ´ÑŒ Ğ¸Ğ· Ğ¿ÑƒĞ»Ğ°
    cl_command_queue queue1 = pool.AcquireQueue();
    cl_command_queue queue2 = pool.AcquireQueue();
    
    // Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¾Ñ‡ĞµÑ€ĞµĞ´Ğ¸ Ğ´Ğ»Ñ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹
    clEnqueueNDRangeKernel(queue1, kernel1, 1, nullptr, 
                           &global_size, &local_size, 0, nullptr, nullptr);
    clEnqueueNDRangeKernel(queue2, kernel2, 1, nullptr,
                           &global_size, &local_size, 0, nullptr, nullptr);
    
    // Ğ’ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ğ¾Ñ‡ĞµÑ€ĞµĞ´Ğ¸ Ğ² Ğ¿ÑƒĞ»
    pool.ReleaseQueue(queue1);
    pool.ReleaseQueue(queue2);
}
```

### ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ 2: ĞÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ñ‹Ğµ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ñ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¸Ğ¼Ğ¸ Ğ¾Ñ‡ĞµÑ€ĞµĞ´ÑĞ¼Ğ¸

```cpp
void asyncProcessing(cl_context context, cl_device_id device,
                     cl_kernel kernels[], int count) {
    drv_gpu_lib::CommandQueuePool pool(context, device, count);
    
    std::vector<cl_command_queue> queues;
    std::vector<cl_event> events;
    
    // Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ kernels Ğ¿Ğ°Ñ€Ğ°Ğ»Ğ»ĞµĞ»ÑŒĞ½Ğ¾
    for (int i = 0; i < count; i++) {
        cl_command_queue queue = pool.AcquireQueue();
        queues.push_back(queue);
        
        cl_event event;
        clEnqueueNDRangeKernel(queue, kernels[i], 1, nullptr,
                               &global_size, &local_size, 
                               i > 0 ? &events.back() : 0,
                               nullptr, &event);
        events.push_back(event);
    }
    
    // Ğ”Ğ¾Ğ¶Ğ´Ğ°Ñ‚ÑŒÑÑ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ Ğ²ÑĞµÑ… Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹
    clWaitForEvents(events.size(), events.data());
    
    // ĞÑĞ²Ğ¾Ğ±Ğ¾Ğ´Ğ¸Ñ‚ÑŒ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ
    for (auto& event : events) {
        clReleaseEvent(event);
    }
    
    // Ğ’ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ğ¾Ñ‡ĞµÑ€ĞµĞ´Ğ¸ Ğ² Ğ¿ÑƒĞ»
    for (auto& queue : queues) {
        pool.ReleaseQueue(queue);
    }
}
```

### ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ 3: Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ DrvGPU

```cpp
#include "DrvGPU/drv_gpu.hpp"

void processWithDrvGPU() {
    drv_gpu_lib::DrvGPU gpu(drv_gpu_lib::BackendType::OPENCL, 0);
    gpu.Initialize();
    
    // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¿ÑƒĞ» Ğ¾Ñ‡ĞµÑ€ĞµĞ´ĞµĞ¹ Ñ‡ĞµÑ€ĞµĞ· Ğ±ÑĞºĞµĞ½Ğ´
    auto& backend = gpu.GetBackend();
    
    // OpenCLBackend Ğ¿Ñ€ĞµĞ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ÑĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ğ¿ÑƒĞ»Ñƒ
    cl_command_queue queue = backend.AcquireCommandQueue();
    
    // Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¾Ñ‡ĞµÑ€ĞµĞ´ÑŒ
    clEnqueueNDRangeKernel(queue, kernel, 1, nullptr,
                           &global_size, &local_size, 0, nullptr, nullptr);
    
    // Ğ’ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ğ¾Ñ‡ĞµÑ€ĞµĞ´ÑŒ
    backend.ReleaseCommandQueue(queue);
    
    gpu.Cleanup();
}
```

---

## Thread Safety

`CommandQueuePool` ÑĞ²Ğ»ÑĞµÑ‚ÑÑ thread-safe Ğ±Ğ»Ğ°Ğ³Ğ¾Ğ´Ğ°Ñ€Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ `std::mutex`.

### Ğ“Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ğ¸ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¾Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸

| ĞĞ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ | Thread Safety | Notes |
|----------|---------------|-------|
| `AcquireQueue()` | Ğ”Ğ° | Ğ‘Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ Ğ¿Ñ€Ğ¸ Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²Ğ¸Ğ¸ ÑĞ²Ğ¾Ğ±Ğ¾Ğ´Ğ½Ñ‹Ñ… Ğ¾Ñ‡ĞµÑ€ĞµĞ´ĞµĞ¹ |
| `ReleaseQueue()` | Ğ”Ğ° | Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°Ñ‚ÑŒ Ğ»ÑĞ±ÑƒÑ Ğ¾Ñ‡ĞµÑ€ĞµĞ´ÑŒ |
| `GetPoolSize()` | Ğ”Ğ° | ĞšĞ¾Ğ½ÑÑ‚Ğ°Ğ½Ñ‚Ğ½Ğ°Ñ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ |
| `SynchronizeAll()` | Ğ”Ğ° | Ğ‘Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ğ¿ÑƒĞ»Ñƒ |
| `Clear()` | Ğ”Ğ° | Ğ¢Ñ€ĞµĞ±ÑƒĞµÑ‚ ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ğ²ÑĞµÑ… Ğ¾Ñ‡ĞµÑ€ĞµĞ´ĞµĞ¹ |

### ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ Ğ¼Ğ½Ğ¾Ğ³Ğ¾Ğ¿Ğ¾Ñ‚Ğ¾Ñ‡Ğ½Ğ¾Ğ³Ğ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ

```cpp
void parallelProcessing(cl_context context, cl_device_id device, int num_threads) {
    drv_gpu_lib::CommandQueuePool pool(context, device, num_threads);
    
    std::vector<std::thread> threads;
    
    for (int i = 0; i < num_threads; i++) {
        threads.emplace_back([&pool, i]() {
            // ĞšĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ğ¿Ğ¾Ñ‚Ğ¾Ğº Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ ÑĞ²Ğ¾Ñ Ğ¾Ñ‡ĞµÑ€ĞµĞ´ÑŒ
            cl_command_queue queue = pool.AcquireQueue();
            
            // ... Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ñ Ğ¾Ñ‡ĞµÑ€ĞµĞ´ÑŒÑ ...
            
            // Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğ¾Ñ‡ĞµÑ€ĞµĞ´Ğ¸
            pool.ReleaseQueue(queue);
        });
    }
    
    for (auto& t : threads) {
        t.join();
    }
}
```

---

## ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸

### ĞšĞ¾Ğ³Ğ´Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Command Queue Pool

| Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ | ĞŸÑ€ĞµĞ¸Ğ¼ÑƒÑ‰ĞµÑÑ‚Ğ²Ğ¾ |
|----------|--------------|
| ĞœĞ½Ğ¾Ğ³Ğ¾Ğ¿Ğ¾Ñ‚Ğ¾Ñ‡Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ | Ğ˜Ğ·Ğ±ĞµĞ¶Ğ°Ñ‚ÑŒ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ¾Ğº Ğ¿Ñ€Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğ¸ Ğ¾Ñ‡ĞµÑ€ĞµĞ´ĞµĞ¹ |
| ĞÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ñ‹Ğµ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ | ĞŸĞ°Ñ€Ğ°Ğ»Ğ»ĞµĞ»ÑŒĞ½Ğ¾Ğµ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ kernel |
| Ğ’Ñ‹ÑĞ¾ĞºĞ°Ñ Ğ½Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° | Ğ£Ğ¼ĞµĞ½ÑŒÑˆĞµĞ½Ğ¸Ğµ overhead ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¾Ñ‡ĞµÑ€ĞµĞ´ĞµĞ¹ |
| Pipeline Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° | ĞšĞ¾Ğ½Ğ²ĞµĞ¹ĞµÑ€Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹ |
| Real-time ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹ | ĞŸÑ€ĞµĞ´ÑĞºĞ°Ğ·ÑƒĞµĞ¼Ğ¾Ğµ Ğ²Ñ€ĞµĞ¼Ñ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ° |

### Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ğ¸Ğ¸ Ğ¿Ğ¾ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ñƒ Ğ¿ÑƒĞ»Ğ°

```cpp
// Ğ”Ğ»Ñ Ğ¾Ğ´Ğ½Ğ¾Ğ¿Ğ¾Ñ‚Ğ¾Ñ‡Ğ½Ñ‹Ñ… Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹: 1-2 Ğ¾Ñ‡ĞµÑ€ĞµĞ´Ğ¸
CommandQueuePool pool(context, device, 1);

// Ğ”Ğ»Ñ Ğ¼Ğ½Ğ¾Ğ³Ğ¾Ğ¿Ğ¾Ñ‚Ğ¾Ñ‡Ğ½Ñ‹Ñ…: ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¾Ğ² Ğ¸Ğ»Ğ¸ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ
int num_threads = std::thread::hardware_concurrency();
CommandQueuePool pool(context, device, num_threads * 2);

// Ğ”Ğ»Ñ Ğ²Ñ‹ÑĞ¾ĞºĞ¾Ğ¹ Ğ½Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸: Ğ´Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ¾Ğµ Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ğµ
CommandQueuePool pool(context, device, 8);
pool.SetMaxSize(32);  // ĞĞµ Ğ±Ğ¾Ğ»ĞµĞµ 32 Ğ¾Ñ‡ĞµÑ€ĞµĞ´ĞµĞ¹
```

### Ğ¡Ñ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸

| ĞœĞµÑ‚Ğ¾Ğ´ | Ğ’Ñ€ĞµĞ¼Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ | Overhead Ğ½Ğ° Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ |
|-------|----------------|---------------------|
| Ğ‘ĞµĞ· Ğ¿ÑƒĞ»Ğ° (clCreateCommandQueue) | ~100-500 Ğ¼ĞºÑ | - |
| CommandQueuePool::AcquireQueue | ~1-10 Ğ¼ĞºÑ | ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ |
| ĞŸĞ¾Ğ²Ñ‚Ğ¾Ñ€Ğ½Ğ¾Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ | - | ~0 Ğ¼ĞºÑ |

---

## Ğ¡Ğ²Ğ¾Ğ´Ğ½Ğ°Ñ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ° Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²

| Ğ¤Ğ°Ğ¹Ğ» | ĞšĞ»Ğ°ÑÑ | ĞĞ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ | Ğ¡Ğ»Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ |
|------|-------|------------|-----------|
| `command_queue_pool.hpp` | `CommandQueuePool` | Ğ˜Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ğ¿ÑƒĞ»Ğ° | Ğ¡Ñ€ĞµĞ´Ğ½ÑÑ |
| `command_queue_pool.cpp` | `CommandQueuePool` | Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ | Ğ¡Ñ€ĞµĞ´Ğ½ÑÑ |
| `opencl_backend.hpp` | `OpenCLBackend` | Ğ‘ÑĞºĞµĞ½Ğ´ Ñ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸ĞµĞ¹ | Ğ’Ñ‹ÑĞ¾ĞºĞ°Ñ |
| `opencl_backend.cpp` | `OpenCLBackend` | Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ | Ğ’Ñ‹ÑĞ¾ĞºĞ°Ñ |

---

## Ğ—Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸

```
CommandQueuePool
    â”œâ”€â”€ CL/cl.h (OpenCL)
    â””â”€â”€ std::mutex, std::vector (C++ STL)

OpenCLBackend
    â”œâ”€â”€ CommandQueuePool
    â”œâ”€â”€ OpenCLCore
    â”œâ”€â”€ IBackend
    â””â”€â”€ Logger
```

---

## Roadmap

| Ğ’ĞµÑ€ÑĞ¸Ñ | Ğ˜Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ | Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ |
|--------|-----------|--------|
| v1.0 | Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹ CommandQueuePool | âœ… Ğ“Ğ¾Ñ‚Ğ¾Ğ² |
| v1.1 | Ğ”Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ¾Ğµ Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ğµ Ğ¿ÑƒĞ»Ğ° | ğŸ“‹ ĞŸĞ»Ğ°Ğ½ |
| v1.2 | Profiling queue support | ğŸ“‹ ĞŸĞ»Ğ°Ğ½ |
| v2.0 | ĞÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ñ‹Ğµ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ | ğŸ“‹ ĞŸĞ»Ğ°Ğ½ |

---

## Ğ—Ğ°ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ

Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Command Queue Ğ² DrvGPU Ğ¿Ñ€ĞµĞ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ÑĞµÑ‚:

- âœ… **Object Pool** Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½ Ğ´Ğ»Ñ ÑÑ„Ñ„ĞµĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾Ğ³Ğ¾ Ğ¿ĞµÑ€ĞµĞ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¾Ñ‡ĞµÑ€ĞµĞ´ĞµĞ¹
- âœ… **Thread-safe** Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ğ´Ğ»Ñ Ğ¼Ğ½Ğ¾Ğ³Ğ¾Ğ¿Ğ¾Ñ‚Ğ¾Ñ‡Ğ½Ñ‹Ñ… Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹
- âœ… **Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ** Ñ OpenCLBackend Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ·Ñ€Ğ°Ñ‡Ğ½Ğ¾Ğ³Ğ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
- âœ… **Ğ“Ğ¸Ğ±ĞºĞ¾ÑÑ‚ÑŒ** Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ° Ğ¸ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ¾Ğ² Ğ¿ÑƒĞ»Ğ°

**Ğ¡Ğ¼. Ñ‚Ğ°ĞºĞ¶Ğµ**:
- [OpenCL.md](OpenCL.md) â€” OpenCL Ğ±ÑĞºĞµĞ½Ğ´
- [Architecture.md](Architecture.md) â€” Ğ¾Ğ±Ñ‰Ğ°Ñ Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°
